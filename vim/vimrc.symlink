set shell=/bin/zsh

""""""""""""" < Vundle Setup > """""""""""""""
set nocompatible
filetype off

""" Bootstrap vundle if this is a new install.
if !isdirectory($HOME . '/.vim/bundle/Vundle.vim')
  if executable('git')
    if has('win32') || has ('win64')
      execute '!"git clone https://github.com/gmarik/vundle.git "'
      \ . $HOME . '/.vim/bundle/Vundle.vim""'
    else
      execute '!git clone https://github.com/gmarik/vundle.git "'
      \ . $HOME . '/.vim/bundle/Vundle.vim"'
    endif
    autocmd VimEnter * PluginInstall
  else
    let choice =  confirm("You should get Git to be able to
      \ Install and Update. Continue?", "&Yes\n&No", 2)
    if choice == 2
      quit
    endif
  endif
endif
" Now we can assume the vundle is installed.
""""""""""""" </ Vundle Setup > """"""""""""""

"""""""""""" < Vundle Plugins > """"""""""""""
set rtp+=~/.vim/bundle/Vundle.vim
set rtp+=~/.fzf
call vundle#begin()

" Plugin Management
Plugin 'VundleVim/Vundle.vim'

" Aesthetics
Plugin 'xolox/vim-misc'                   " Misc needed for other plugins?
Plugin 'vim-airline/vim-airline'          " Better status bar
Plugin 'vim-airline/vim-airline-themes'
Plugin 'flazz/vim-colorschemes'
Plugin 'valloric/MatchTagAlways'
Plugin 'nathanaelkane/vim-indent-guides'  " Colored tab indent levels
Plugin 'croaker/mustang-vim'

" Languages
Plugin 'scrooloose/syntastic'
Plugin 'sheerun/vim-polyglot'

" Searching
Plugin 'ervandew/ag'
Plugin 'kien/ctrlp.vim'                 " Fuzzy file search from current dir.
" Plugin 'xolox/vim-easytags'

" Windows and Buffers
Plugin 'majutsushi/tagbar'              " Display ctags in a sidebar.
Plugin 'godlygeek/tabular'              " Needed for vim-markdown, should be loaded in this order
Plugin 'scrooloose/nerdtree'            " File navigation buffer
Plugin 'rbgrouleff/bclose.vim'
Plugin 'ap/vim-buftabline'
Plugin 'benmills/vimux'

" Input
Plugin 'terryma/vim-multiple-cursors'
Plugin 'ervandew/supertab'
Plugin 'scrooloose/nerdcommenter'        " Line comment toggling
Plugin 'Townk/vim-autoclose'
Plugin '907th/vim-auto-save'

" Markdown
Plugin 'plasticboy/vim-markdown'
Plugin 'KeitaNakamura/tex-conceal.vim'
Plugin 'dkarter/bullets.vim'

" Latex
Plugin 'lervag/vimtex'
Plugin 'SirVer/ultisnips'
" Snippets are separated from the engine. Add this if you want them:
Plugin 'honza/vim-snippets'


call vundle#end()
"""""""""""" </ Vundle Plugins > """""""""""""""
" call pathogen#infect()

set nocompatible
set viminfo='1000,f1,:1000,/1000
set history=1000

"------  Visual Options  ------
syntax on
set number
set nowrap
set vb
set ruler
"set statusline=%<%f\ %h%m%r%=%{fugitive#statusline()}\ \ %-14.(%l,%c%V%)\ %P
let g:buftabs_only_basename=1
let g:buftabs_marker_modified = "+"
set t_ut=

"set listchars=eol:$,tab:>-,trail:~,extends:>,precedes:<

" Linebreak on 500 characters
set lbr
set tw=500

" Treat long lines as break lines (useful when moving around in them)
nnoremap j gj
nnoremap k gk

"""------  Generic Behavior  ------
" Use spaces instead of tabs (necessary for haskell/ghc)
set tabstop=2     " Inserts 2 spaces when tab key is pressed.
set softtabstop=2 " Deletes 2 spaces (simulates deleting a tab)
set shiftwidth=2  " Inserts 2 spaces for auto-indentation.
set expandtab     " Insert spaces whenever tab key is pressed.
set smarttab      " ?
set shiftround    " Round indent to nearest 'shiftwidth' multiple

set hidden
filetype indent on
filetype plugin on
set autoindent    " Match indentation level when moving to new line.
set smartindent

"allow deletion of previously entered data in insert mode
set backspace=indent,eol,start

set viminfo^=%                    " Remember info about open buffers on close

set wildmenu                      " Turn on the WiLd menu
set wildmode=list:longest,full    " Tab-complete files up to longest unambiguous prefix

" For the love of god, don't grep min files!
set wildignore=.svn,CVS,.git,*.o,*.a,*.class,*.mo,*.la,*.so,*.obj,*.swp,*.jpg,*.png,*.xpm,*.gif,node_modules/*
set wildignore+=*.min,*.min.js,*.tmp,*.svg

set ignorecase                    " Ignore case when searching
set smartcase                     " When searching try to be smart about cases

set lazyredraw                    " Don't redraw while executing macros (good performance config)

set nobackup                      " Turn backup off (store everything in version control)
set nowb
set noswapfile

set wrap                          " Wrap lines longer than window width

" Not compiled into some versions of vim, i.e. ubuntu default repos.
if exists("&breakindent")
  set breakindent                   " Indent wraps to same level as original line
endif

" set breakindent                   " Indent wraps to same level as original line
" Incompatible with debian vim?


"""""""""""""""""""" <Misc> """"""""""""""
" Automatically use the system clipboard for copy-paste (instead of internal registers)
set clipboard+=unnamedplus

" GUI Settings
set t_Co=256
colorscheme elflord

set mouse=a                     " Allow mouse selection

set showmatch                   " Show matching parens
set smarttab                    " Indents based on sw, not ts
set hlsearch                    " Highlight search terms
set incsearch                   " Show search matches as typed

set backspace=indent,eol,start  " Allow backspace over anything
set ff=unix                     " Default to Unix LF line endings

set noswapfile                  " Use version control instead

" Make sure unicode works properly (primarily for concealing)
set encoding=utf-8
let &termencoding=&encoding
"""""""""""""   < Keymaps > """"""""""""""""""

let mapleader=","

" Haskell shortcuts
"map <silent> <Leader>hc :SyntasticCheck<CR>
"nmap <silent> <leader>hl :SyntasticCheck hlint<CR>
"map <Leader>m :w \| make<CR>

"map <Leader>m :w \| !xelatex --interaction=batchmode %; rm *.{aux,log,out,dvi,nav,toc,pre,tdo}<CR><CR>
"autocmd BufWritePost *.tex :silent execute "!xelatex --interaction=batchmode %; rm *.{aux,log,out}" | redraw!
"let blacklist = ['preamble.tex']
"autocmd BufWritePost *.tex if expand('%:t') != "preamble.tex" | :silent execute "!pdflatex %; rm *.{aux,log,out}" | redraw!

" Then type in word to ag from the curent directory
map <Leader>/ :Ag!<SPACE>

" Ag the word under the cursor.
nmap <Leader>// :<c-u>execute 'Ag! ' .  expand("<cWORD>")<CR>

" Toggle whitespace visibility
nmap <Leader>s :set list!<CR>

nmap <leader>= :TagbarToggle<CR>

" Allow saving of read-only files when opened without sudo.
cmap wf %!sudo tee > /dev/null %

" Save a few keystrokes
nnoremap ; :

" ,q Closes the current buffer
nnoremap <silent> <Leader>q :Bclose<CR>

" cscope the word under the cursor
nnoremap <silent> <C-\> :cs find c <C-R>=expand("<cword>")<CR><CR>

" Clear search highlights when pressing ,b
nnoremap <silent> <leader>b :nohlsearch<CR>

" Press enter to clear search highlights
nnoremap <CR> :noh<CR><CR>

" Toggle NerdTree visibility using ,n
noremap <silent> <Leader>n :NERDTreeToggle<CR>

" ,hljk = Move between windows
nnoremap <Leader>h <C-w>h
nnoremap <Leader>l <C-w>l
nnoremap <Leader>j <C-w>j
nnoremap <Leader>k <C-w>k

" Ctrl Left/h & Right/l cycle between buffers
noremap <silent> <C-Left> :bprev<CR>
noremap <silent> <C-h> :bprev<CR>
noremap <silent> <C-Right> :bnext<CR>
noremap <silent> <C-l> :bnext<CR>

" Some custom programming commands
nnoremap <Leader>mm :wa \| :VimuxRunCommand 'make clean && make all && ./test'<CR>
nnoremap <leader>cap :wa \| :VimuxRunCommand 'git add *; git commit -am "save"; git push origin master'<CR>
" Close buffer without affecting splits.
nnoremap <leader>w :Bclose<CR>

" Cmd+t = new tab
nnoremap <silent> <Leader>t :tabnew<CR>

" Cmd+w = close tab (this should happen by default)
"nnoremap <silent> <Leader>w :tabclose<CR>

" Cmd+Shift+N = new buffer
" map <silent> <Leader>n :enew<CR>

" Toggle between absolute and relative line numbers
function! NumberToggle()
  if (&relativenumber == 1)
    set norelativenumber
  else
    set relativenumber
  endif
endfunc

nnoremap <Leader>el :call NumberToggle()<CR>

""""""""""""" < /Keymaps > """"""""""""""""""""""""""""""
set statusline+=%#warningmsg#
set statusline+=%{SyntasticStatuslineFlag()}
set statusline+=%*

set laststatus=2
set statusline=%<%f\                        " Filename
set statusline+=%w%h%m%r                    " Options
set statusline+=%{fugitive#statusline()}    " Git hotness
set statusline+=\ [%{&ff}/%Y]               " filetype
set statusline+=\ [%{getcwd()}]             " current dir
set statusline+=%=%-14.(%l,%c%V%)\ %p%%     " Right aligned file nav info

" Prevent cursor from moving to beginning of line when switching buffers
set nostartofline

" Keep the cursor in place while joining lines
nnoremap J mzJ`z


""""""""" < Search > """""""""""
set incsearch
set ignorecase
set smartcase
set hlsearch

" When searching for words with * and navigating with N/n, keep line centered vertically
nnoremap n nzz
nnoremap N Nzz
nnoremap * *zz
nnoremap # #zz
nnoremap g* g*zz
nnoremap g# g#zz
""""""""" </ Search > """""""""""


""""""""""""" < NerdTree > """"""""""""""""""
" Always open NerdTree along with files
" and switch focus to file
" au VimEnter * NERDTree | wincmd p

" Custom commands for NERDTree
autocmd StdinReadPre * let s:std_in=1
" autocmd VimEnter * if argc() == 0 && !exists("s:std_in") | NERDTree | endif

let NERDTreeIgnore=['CVS','\.dSYM$']

"setting root dir in NT also sets VIM's cd
let NERDTreeChDirMode=2

let g:NERDTreeDirArrows=0

" These prevent accidentally loading files while focused on NERDTree
autocmd FileType nerdtree noremap <buffer> <c-left> <nop>
autocmd FileType nerdtree noremap <buffer> <c-h> <nop>
autocmd FileType nerdtree noremap <buffer> <c-right> <nop>
autocmd FileType nerdtree noremap <buffer> <c-l> <nop>

" Open NERDTree if we're executing vim without specifying a file to open
autocmd vimenter * if !argc() | NERDTree | endif

" Close if only NERDTree open
autocmd bufenter * if (winnr("$") == 1 && exists("b:NERDTreeType") && b:NERDTreeType == "primary") | q | endif

" Hides "Press ? for help"
let NERDTreeMinimalUI=1
""""""""""""" </ NerdTree > """"""""""""""""""

"au FileType php set omnifunc=phpcomplete#CompletePHP
" ----- </ PHP > -------------------

" Column 80 marker
" highlight OverLength ctermbg=red ctermfg=white guibg=#660000
" match OverLength /\%81v.\+/

" Sane vimdiff colorscheme
highlight DiffAdd    cterm=bold ctermfg=10 ctermbg=17 gui=none guifg=bg guibg=Red
highlight DiffDelete cterm=bold ctermfg=10 ctermbg=17 gui=none guifg=bg guibg=Red
highlight DiffChange cterm=bold ctermfg=10 ctermbg=17 gui=none guifg=bg guibg=Red
highlight DiffText   cterm=bold ctermfg=10 ctermbg=88 gui=none guifg=bg guibg=Red

" Turn on HTML tag matching
runtime macros/matchit.vim

"""""""""" < CtrlP >
" CtrlP will load from the CWD, makes it easier with all these nested repos
let g:ctrlp_working_path_mode = ''

let g:ctrlp_map = '<c-p>'
let g:ctrlp_cmd = 'CtrlP'
let g:ctrlp_working_path_mode='ra'

let g:ctrlp_clear_cache_on_exit=0       " Save cache for a small speedup.

" Use ag for Ctrl-P for speed improvement.
if executable('ag')
    set grepprg=ag\ --nogroup\ --nocolor
    let g:ctrlp_user_command = 'ag %s -l --nocolor -g ""'
    let g:ctrlp_use_caching=0
endif
"""""""""" </ CtrlP >

" Close NerdTree if it is the only buffer left open.
function! NERDTreeQuit()
  redir => buffersoutput
  silent buffers
  redir END
"                     1BufNo  2Mods.     3File           4LineNo
  let pattern = '^\s*\(\d\+\)\(.....\) "\(.*\)"\s\+line \(\d\+\)$'
  let windowfound = 0

  for bline in split(buffersoutput, "\n")
    let m = matchlist(bline, pattern)

    if (len(m) > 0)
      if (m[2] =~ '..a..')
        let windowfound = 1
      endif
    endif
  endfor

  if (!windowfound)
    quitall
  endif
endfunction
autocmd WinEnter * call NERDTreeQuit()

" Remove trailing whitespace before writing (applies to all files)
autocmd BufWritePre * :%s/\s\+$//e

" Recognize .md files as markdown
autocmd BufNewFile,BufReadPost *.md set filetype=markdown

" Return to last edit position when opening files
augroup last_edit
  autocmd!
  autocmd BufReadPost *
       \ if line("'\"") > 0 && line("'\"") <= line("$") |
       \   exe "normal! g`\"" |
       \ endif
augroup END

" Source the vimrc file after saving it
augroup sourcing
  autocmd!
  autocmd bufwritepost .vimrc source $MYVIMRC
augroup END

" After narrowing choices, allows pressing enter to select last entry in popup menu.
inoremap <expr> <CR> pumvisible() ? "\<C-y>" : "\<C-g>u\<CR>"

" Display buffers in tabs when only one tab is open
let g:airline#extensions#tabline#enabled = 1

let g:syntastic_always_populate_loc_list = 1
let g:syntastic_auto_loc_list = 0
let g:syntastic_check_on_open = 0
let g:syntastic_check_on_wq = 0
let g:syntastic_cpp_compiler_options=' -std=c++11 -stdlib=libc++'

" Enable syntax checking on write/close, but disable on haskell files
" (Intensive for large projects)
let g:syntastic_mode_map = {
        \ "mode": "active",
        \ "active_filetypes": ["ruby", "php"],
        \ "passive_filetypes": ["haskell", "tex"] }
let g:syntastic_enable_signs=1

" Automatically :set-paste when pasting from clipboard, in insert mode
function! WrapForTmux(s)
  if !exists('$TMUX')
    return a:s
  endif

  let tmux_start = "\<Esc>Ptmux;"
  let tmux_end = "\<Esc>\\"

  return tmux_start . substitute(a:s, "\<Esc>", "\<Esc>\<Esc>", 'g') . tmux_end
endfunction

let &t_SI .= WrapForTmux("\<Esc>[?2004h")
let &t_EI .= WrapForTmux("\<Esc>[?2004l")

function! XTermPasteBegin()
  set pastetoggle=<Esc>[201~
  set paste
  return ""
endfunction

inoremap <special> <expr> <Esc>[200~ XTermPasteBegin()

let g:tex_conceal = ""
let g:vim_markdown_math = 1
let g:vim_markdown_frontmatter = 1
let g:vim_markdown_toc_autofit = 1
let g:vim_markdown_follow_anchor = 1
let g:vim_markdown_frontmatter = 1
let g:vim_markdown_new_list_item_indent = 0

"autocmd BufRead,BufNewFile *.md,tex,latex setlocal spell
autocmd FileType markdown,tex,latex setlocal spell
" Fix the omnicomplete popup menu a bit
" Allows typing in a few characters to narrow down the list
set completeopt=longest,menuone
"set complete=kspell,.
set complete+=kspell
set complete+=k/home/zack/math_dict.txt
set spelllang=en
set spellfile=/home/zack/mathdict.utf-8.add
set conceallevel=2
" Use buffer words as default tab completion
"let g:SuperTabDefaultCompletionType = '<c-x><c-p>'
autocmd FileType *
  \ if &omnifunc != '' |
  \   call SuperTabChain(&omnifunc, "<c-p>") |
  \ endif

let g:tex_conceal="abdgm"
au FileType markdown autocmd VimEnter * hi clear Conceal         " Remove background color from concealed characters (grey on grey??)

hi NonText ctermbg=none
hi Normal guibg=NONE ctermbg=NONE

" Automatically re-read changed files
set autoread

" Automatically save after a few seconds
au CursorHold *.tex,*.md  update

" inoremap { {}<Esc>i
let g:polyglot_disabled = ['latex']

"let g:UltiSnipsExpandTrigger="<c-b>"
"let g:UltiSnipsJumpForwardTrigger="<c-h>"
"let g:UltiSnipsJumpBackwardTrigger="<c-g>"
let g:UltiSnipsExpandTrigger="<tab>"
let g:UltiSnipsJumpForwardTrigger="<tab>"
let g:UltiSnipsJumpBackwardTrigger="<s-tab>"

" Hit Ctrl-L to correct last spelling mistake
inoremap <C-l> <c-g>u<Esc>[s1z=`]a<c-g>u

" Include figures
"inoremap <C-f> <Esc>: silent exec '.!inkscape-figures create "'.getline('.').'" "'.b:vimtex.root.'/figures/"'<CR><CR>:w<CR>
nnoremap <C-f> : exec '!inkscape-figures create "'.expand('%:p:h').'/figures/" > /dev/null 2>&1 &'
"nnoremap <C-f> : silent exec '!echo "'.expand<F11>('%:p:h').'/figures/" '
"nnoremap <C-f> : exec echo expand('%:p:h')

set foldlevel=20

" Autosave settings
let g:auto_save        = 1
let g:auto_save_silent = 1
let g:auto_save_events = ["InsertLeave", "FocusLost"]

" Persistent Undo
let s:undoDir = "/tmp/.undodir_" . $USER
if !isdirectory(s:undoDir)
    call mkdir(s:undoDir, "", 0700)
endif
let &undodir=s:undoDir
set undofile

" Press Ctrl-B to change this line to a latex begin/end.
map  <C-B>      YpkI\begin{<ESC>A}<ESC>jI\end{<ESC>A}<esc>k$o
map! <C-B> <ESC>YpkI\begin{<ESC>A}<ESC>jI\end{<ESC>A}<esc>k$o

map  <C-B>      YpkI\begin{<ESC>A}<ESC>jI\end{<ESC>A}<esc>k$o
map! <C-B> <ESC>YpkI\begin{<ESC>A}<ESC>jI\end{<ESC>A}<esc>k$o

" Quickly insert an empty new line without entering insert mode
nnoremap <Leader>o o<Esc>
nnoremap <Leader>O O<Esc>

map <Leader>m  I$$<CR><CR>.$$<ESC>k<ESC>
