""""""""""""" < Vundle Setup > """""""""""""""
set nocompatible
filetype off

""" Bootstrap vundle if this is a new install.
if !isdirectory($HOME . '/.vim/bundle/Vundle.vim')
  if executable('git')
    if has('win32') || has ('win64')
      execute '!"git clone https://github.com/gmarik/vundle.git "'
      \ . $HOME . '/.vim/bundle/Vundle.vim""'
    else
      execute '!git clone https://github.com/gmarik/vundle.git "'
      \ . $HOME . '/.vim/bundle/Vundle.vim"'
    endif
    autocmd VimEnter * PluginInstall
  else
    let choice =  confirm("You should get Git to be able to
      \ Install and Update. Continue?", "&Yes\n&No", 2)
    if choice == 2
      quit
    endif
  endif
endif
" Now we can assume the vundle is installed.
""""""""""""" </ Vundle Setup > """""""""""""""

"""""""""""" < Vundle Plugins > """""""""""""""
set rtp+=~/.vim/bundle/Vundle.vim
set rtp+=~/.fzf
call vundle#begin()

" Plugin Management
Plugin 'gmarik/vundle'

" Aesthetics
Plugin 'xolox/vim-misc'
Plugin 'bling/vim-airline'                " Improve the status bar
Plugin 'flazz/vim-colorschemes'
Plugin 'valloric/MatchTagAlways'
Plugin 'nathanaelkane/vim-indent-guides'  " Colored tab indent levels

" Git
Plugin 'tpope/vim-fugitive'
Plugin 'airblade/vim-gitgutter'         " Show git difs next to line numbers.

" Langauges
Plugin 'scrooloose/syntastic'
Plugin 'sheerun/vim-polyglot'

"" Haskell
" Plugin 'dag/vim2hs'                     " Fixes highlighting for top-level defs, but slows startup noticeably for large files (>400 lines)
Plugin 'eagletmt/neco-ghc'                " Provides completions using ghc-mod
Plugin 'shougo/vimproc.vim'               " Dependency for ghc-mod
Plugin 'eagletmt/ghcmod-vim'              " Infer and display types
" Plugin 'bitc/vim-hdevtools'
Plugin 'lukerandall/haskellmode-vim'
Plugin 'enomsg/vim-haskellConcealPlus'    " Swap in unicode symbols for haskell ops.

"" Web Dev
" Plugin 'shawncplus/phpcomplete.vim'

" Searching
Plugin 'ervandew/ag'
Plugin 'kien/ctrlp.vim'                 " Fuzzy file search from current dir.
" Plugin 'xolox/vim-easytags'

" Windows and Buffers
Plugin 'majutsushi/tagbar'              " Display ctags in a sidebar.
Plugin 'godlygeek/tabular'
Plugin 'scrooloose/nerdtree'            " File navigation buffer
Plugin 'rbgrouleff/bclose.vim'

" Input
Plugin 'terryma/vim-multiple-cursors'
Plugin 'ervandew/supertab'
Plugin 'scrooloose/nerdcommenter'        " Line comment toggling

" Markdown
Plugin 'plasticboy/vim-markdown'

call vundle#end()
"""""""""""" </ Vundle Plugins > """""""""""""""


call pathogen#infect()

set nocompatible
set viminfo='1000,f1,:1000,/1000
set history=1000


"------  Visual Options  ------
syntax on
set number
set nowrap
set vb
set ruler
"set statusline=%<%f\ %h%m%r%=%{fugitive#statusline()}\ \ %-14.(%l,%c%V%)\ %P
let g:buftabs_only_basename=1
let g:buftabs_marker_modified = "+"

"set listchars=eol:$,tab:>-,trail:~,extends:>,precedes:<

" Linebreak on 500 characters
set lbr
set tw=500

" Treat long lines as break lines (useful when moving around in them)
nnoremap j gj
nnoremap k gk
"""------  Generic Behavior  ------
" Use spaces instead of tabs (necessary for haskell/ghc)
set tabstop=2     " Inserts 2 spaces when tab key is pressed.
set softtabstop=2 " Deletes 2 spaces (simulates deleting a tab)
set shiftwidth=2  " Inserts 2 spaces for auto-indentation.
set expandtab     " Insert spaces whenever tab key is pressed.
set smarttab      " ?
set shiftround    " Round indent to nearest 'shiftwidth' multiple

set hidden
filetype indent on
filetype plugin on
set autoindent    " Match indentation level when moving to new line.
set smartindent

"allow deletion of previously entered data in insert mode
set backspace=indent,eol,start

set viminfo^=%                    " Remember info about open buffers on close

set wildmenu                      " Turn on the WiLd menu
set wildmode=list:longest,full    " Tab-complete files up to longest unambiguous prefix

" For the love of god, don't grep min files!
set wildignore=.svn,CVS,.git,*.o,*.a,*.class,*.mo,*.la,*.so,*.obj,*.swp,*.jpg,*.png,*.xpm,*.gif,node_modules/*
set wildignore+=*.min,*.min.js,*.tmp,*.svg

set ignorecase                    " Ignore case when searching
set smartcase                     " When searching try to be smart about cases

set lazyredraw                    " Don't redraw while executing macros (good performance config)

set nobackup                      " Turn backup off (store everything in version control)
set nowb
set noswapfile

set wrap                          " Wrap lines longer than window width
set breakindent                   " Indent wraps to same level as original line

"""""""""""""""""""" <Misc> """"""""""""""
" Allows pasting (S-Insert) from OS clipboard
set clipboard+=unnamed

" GUI Settings
set t_Co=256
colorscheme Mustang

set mouse=a                     " Allow mouse selection

set showmatch                   " Show matching parens
set smarttab                    " Indents based on sw, not ts
set hlsearch                    " Highlight search terms
set incsearch                   " Show search matches as typed

set backspace=indent,eol,start  " Allow backspace over anything
set ffs=unix                    " Default to Unix LF line endings

set noswapfile                  " Use version control instead

" Make sure unicode works properly (primarily for concealing)
set encoding=utf-8
let &termencoding=&encoding
"""""""""""""   < Keymaps > """"""""""""""""""

let mapleader=","

" Haskell shortcuts
map <silent> <Leader>hc :SyntasticCheck<CR>
nmap <silent> <leader>hl :SyntasticCheck hlint<CR>
map <Leader>m :w \| make<CR>
map <Leader>rh :w \| !runhaskell %<CR>
map <Leader>hst :GhcModType<CR>
map <Leader>hsti :GhcModTypeInsert<CR>

" Then type in word to ag from the curent directory
map <Leader>/ :Ag!<SPACE>

" Ag the word under the cursor.
nmap <Leader>// :<c-u>execute 'Ag! ' .  expand("<cWORD>")<CR>

" Toggle whitespace visibility
nmap <Leader>s :set list!<CR>

" nmap <silent> =j :%!python -m json.tool<CR>:setfiletype json<CR>

nmap <leader>= :TagbarToggle<CR>

" Allow saving of read-only files when opened without sudo.
cmap wf %!sudo tee > /dev/null %

" Save a few keystrokes
nnoremap ; :

" ,q Closes the current buffer
nnoremap <silent> <Leader>q :Bclose<CR>

" cscope the word under the cursor
nnoremap <silent> <C-\> :cs find c <C-R>=expand("<cword>")<CR><CR>

" Clear search highlights when pressing ,b
nnoremap <silent> <leader>b :nohlsearch<CR>

" Toggle visibility using ,n
noremap <silent> <Leader>n :NERDTreeToggle<CR>

" ,hljk = Move between windows
nnoremap <Leader>h <C-w>h
nnoremap <Leader>l <C-w>l
nnoremap <Leader>j <C-w>j
nnoremap <Leader>k <C-w>k

" Ctrl Left/h & Right/l cycle between buffers
noremap <silent> <C-left> :bprev<CR>
noremap <silent> <C-h> :bprev<CR>
noremap <silent> <C-right> :bnext<CR>
noremap <silent> <C-l> :bnext<CR>

"------  Fugitive Plugin Options  ------
nnoremap <Leader>ga :Git add %:p<CR>
nnoremap <Leader>gc :Gcommit -v -q<CR>
nnoremap <Leader>gpo :Git push origin master<CR>
nnoremap <Leader>gs :Gstatus<CR>
nnoremap <Leader>gl :Glog<CR>
nnoremap <Leader>gb :Gblame<CR>
nnoremap <Leader>gm :Gmove
nnoremap <Leader>gp :Ggrep
nnoremap <Leader>gR :Gread<CR>
nnoremap <Leader>gd :Gdiff<CR>

" Cmd+t = new tab
nnoremap <silent> <Leader>t :tabnew<CR>

" Cmd+w = close tab (this should happen by default)
nnoremap <silent> <Leader>w :tabclose<CR>

" Cmd+Shift+N = new buffer
" map <silent> <Leader>n :enew<CR>

" Toggle between absolute and relative line numbers
function! NumberToggle()
  if (&relativenumber == 1)
    set norelativenumber
  else
    set relativenumber
  endif
endfunc

nnoremap <Leader>el :call NumberToggle()<CR>
""""""""""""" < /Keymaps > """"""""""""""""""""""""""""""

set statusline+=%#warningmsg#
set statusline+=%{SyntasticStatuslineFlag()}
set statusline+=%*

set laststatus=2
set statusline=%<%f\                        " Filename
set statusline+=%w%h%m%r                    " Options
set statusline+=%{fugitive#statusline()}    " Git hotness
set statusline+=\ [%{&ff}/%Y]               " filetype
set statusline+=\ [%{getcwd()}]             " current dir
set statusline+=%=%-14.(%l,%c%V%)\ %p%%     " Right aligned file nav info

" Prevent cursor from moving to beginning of line when switching buffers
set nostartofline

" Keep the cursor in place while joining lines
nnoremap J mzJ`z


""""""""" < Search > """""""""""
set incsearch
set ignorecase
set smartcase
set hlsearch

" When searching for words with * and navigating with N/n, keep line centered vertically
nnoremap n nzz
nnoremap N Nzz
nnoremap * *zz
nnoremap # #zz
nnoremap g* g*zz
nnoremap g# g#zz
""""""""" </ Search > """""""""""


""""""""""""" < NerdTree > """"""""""""""""""
" Always open NerdTree along with files
" and switch focus to file
" au VimEnter * NERDTree | wincmd p

" Custom commands for NERDTree
autocmd StdinReadPre * let s:std_in=1
" autocmd VimEnter * if argc() == 0 && !exists("s:std_in") | NERDTree | endif

let NERDTreeIgnore=['CVS','\.dSYM$']

"setting root dir in NT also sets VIM's cd
let NERDTreeChDirMode=2

let g:NERDTreeDirArrows=0

" These prevent accidentally loading files while focused on NERDTree
autocmd FileType nerdtree noremap <buffer> <c-left> <nop>
autocmd FileType nerdtree noremap <buffer> <c-h> <nop>
autocmd FileType nerdtree noremap <buffer> <c-right> <nop>
autocmd FileType nerdtree noremap <buffer> <c-l> <nop>

" Open NERDTree if we're executing vim without specifying a file to open
autocmd vimenter * if !argc() | NERDTree | endif

" Close if only NERDTree open
autocmd bufenter * if (winnr("$") == 1 && exists("b:NERDTreeType") && b:NERDTreeType == "primary") | q | endif

" Hides "Press ? for help"
let NERDTreeMinimalUI=1
""""""""""""" </ NerdTree > """"""""""""""""""


"------  JSON Filetype Settings  ------
au BufRead,BufNewFile *.json set filetype=json
let g:vim_json_syntax_conceal = 0
"------ </ JSON > -----------


"------  PHP Filetype Settings  ------
map <Leader>p :! php -l %<CR>   " ,p = Runs PHP lint checker on current file
map <Leader>P :! php -q %<CR>   " ,P = Runs PHP and executes the current file

au FileType php set omnifunc=phpcomplete#CompletePHP
" ----- </ PHP > -------------------

" Column 80 marker
highlight OverLength ctermbg=red ctermfg=white guibg=#660000
match OverLength /\%81v.\+/

" Sane vimdiff colorscheme
highlight DiffAdd    cterm=bold ctermfg=10 ctermbg=17 gui=none guifg=bg guibg=Red
highlight DiffDelete cterm=bold ctermfg=10 ctermbg=17 gui=none guifg=bg guibg=Red
highlight DiffChange cterm=bold ctermfg=10 ctermbg=17 gui=none guifg=bg guibg=Red
highlight DiffText   cterm=bold ctermfg=10 ctermbg=88 gui=none guifg=bg guibg=Red

" Map to run xmllint on current file
map @@x !%xmllint --format --recover -^M

" Function for cleaning an XML document
function! DoCleanXML()
  silent %!xmllint --format --encode utf-8 -
  g/xml version=/d
endfunction

command! CleanXML call DoCleanXML()


"""""" < Haskell > """""""""""
" Include codex tags in tagbar, ^], etc
set tags=tags;/,codex.tags;/

au FileType haskell autocmd VimEnter * hi clear Conceal         " Remove background color from concealed characters (grey on grey??)
" autocmd FileType * nested :call tagbar#autoopen(0)            " Automatically open tagbar
" set foldlevelstart=20                                         " Automatically unfold everything at startup
" au BufEnter *.hs compiler ghc

let g:haddock_browser="/usr/bin/links"
let g:haddock_docdir="/opt/docs/haddock"
let g:haddock_browser_callformat = '%s "%s"'
"""""" </ Haskell > """""""""""


" { Tags
let g:tagbar_type_haskell = {
    \ 'ctagsbin'  : 'hasktags',
    \ 'ctagsargs' : '-x -c -o-',
    \ 'kinds'     : [
        \  'm:modules:0:1',
        \  'd:data: 0:1',
        \  'd_gadt: data gadt:0:1',
        \  't:type names:0:1',
        \  'nt:new types:0:1',
        \  'c:classes:0:1',
        \  'cons:constructors:1:1',
        \  'c_gadt:constructor gadt:1:1',
        \  'c_a:constructor accessors:1:1',
        \  'ft:function types:1:1',
        \  'fi:function implementations:0:1',
        \  'o:others:0:1'
    \ ],
    \ 'sro'        : '.',
    \ 'kind2scope' : {
        \ 'm' : 'module',
        \ 'c' : 'class',
        \ 'd' : 'data',
        \ 't' : 'type'
    \ },
    \ 'scope2kind' : {
        \ 'module' : 'm',
        \ 'class'  : 'c',
        \ 'data'   : 'd',
        \ 'type'   : 't'
    \ }
\ }


"""""""""" < HScope >
set csprg=/app/bin/hscope
set csto=1                " search codex tags first
set cst
set csverb

" Automatically make cscope connections
function! LoadHscope()
  let db = findfile("hscope.out", ".;")
  if (!empty(db))
    let path = strpart(db, 0, match(db, "/hscope.out$"))
    set nocscopeverbose " suppress 'duplicate connection' error
    exe "cs add " . db . " " . path
    set cscopeverbose
  endif
endfunction
au BufEnter /*.hs call LoadHscope()
"""""""""" < /HScope >
" /Tags }


let g:tagbar_autofocus = 1
let g:tagbar_compact = 1

" Turn on HTML tag matching
runtime macros/matchit.vim

"""""""""" < CtrlP >
" CtrlP will load from the CWD, makes it easier with all these nested repos
let g:ctrlp_working_path_mode = ''

let g:ctrlp_map = '<c-p>'
let g:ctrlp_cmd = 'CtrlP'
let g:ctrlp_working_path_mode='ra'

let g:ctrlp_clear_cache_on_exit=0       " Save cache for a small speedup.

" Use ag for Ctrl-P for speed improvement.
if executable('ag')
    set grepprg=ag\ --nogroup\ --nocolor
    let g:ctrlp_user_command = 'ag %s -l --nocolor -g ""'
    let g:ctrlp_use_caching=0
endif
"""""""""" </ CtrlP >

" Close NerdTree if it is the only buffer left open.
function! NERDTreeQuit()
  redir => buffersoutput
  silent buffers
  redir END
"                     1BufNo  2Mods.     3File           4LineNo
  let pattern = '^\s*\(\d\+\)\(.....\) "\(.*\)"\s\+line \(\d\+\)$'
  let windowfound = 0

  for bline in split(buffersoutput, "\n")
    let m = matchlist(bline, pattern)

    if (len(m) > 0)
      if (m[2] =~ '..a..')
        let windowfound = 1
      endif
    endif
  endfor

  if (!windowfound)
    quitall
  endif
endfunction
autocmd WinEnter * call NERDTreeQuit()

" Remove trailing whitespace before writing (applies to all files)
autocmd BufWritePre * :%s/\s\+$//e

" Recognize .md files as markdown
autocmd BufNewFile,BufReadPost *.md set filetype=markdown

" Return to last edit position when opening files
augroup last_edit
  autocmd!
  autocmd BufReadPost *
       \ if line("'\"") > 0 && line("'\"") <= line("$") |
       \   exe "normal! g`\"" |
       \ endif
augroup END

" Source the vimrc file after saving it
augroup sourcing
  autocmd!
  autocmd bufwritepost .vimrc source $MYVIMRC
augroup END


" Use buffer words as default tab completion
let g:SuperTabDefaultCompletionType = '<c-x><c-p>'

" But provide (neco-ghc) omnicompletion
if has("gui_running")
  imap <c-space> <c-r>=SuperTabAlternateCompletion("\<lt>c-x>\<lt>c-o>")<cr>
else " no gui
  if has("unix")
    inoremap <Nul> <c-r>=SuperTabAlternateCompletion("\<lt>c-x>\<lt>c-o>")<cr>
  endif
endif

" Show types in completion suggestions
let g:necoghc_enable_detailed_browse = 1

" Use neco-ghc for omnicompletion
autocmd FileType haskell setlocal omnifunc=necoghc#omnifunc

" Fix the omnicomplete popup menu a bit
" Allows typing in a few characters to narrow down the list
set completeopt=longest,menuone

" After narrowing choices, allows pressing enter to select last entry in popup menu.
inoremap <expr> <CR> pumvisible() ? "\<C-y>" : "\<C-g>u\<CR>"

" Hacks for Syntastic
function! FindCabalSandboxRoot()
    return finddir('.cabal-sandbox', './;')
endfunction

function! FindCabalSandboxRootPackageConf()
    return glob(FindCabalSandboxRoot().'/*-packages.conf.d')
endfunction

let g:syntastic_always_populate_loc_list = 1
let g:syntastic_auto_loc_list = 0
let g:syntastic_check_on_open = 0
let g:syntastic_check_on_wq = 0

" Enable syntax checking on write/close, but disable on haskell files
" (Intensive for large projects)
let g:syntastic_mode_map = {
        \ "mode": "active",
        \ "active_filetypes": ["ruby", "php"],
        \ "passive_filetypes": ["haskell", "tex"] }
let g:hdevtools_options = '-g -cpp -g-ilib -g-isrc -g-i. -g-idist/build/autogen -g-Wall -g-package-conf='.FindCabalSandboxRootPackageConf()
let g:syntastic_enable_signs=1
