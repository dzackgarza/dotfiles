set shell=/bin/zsh

""""""""""""" < Vundle Setup > """""""""""""""
set nocompatible
filetype off

""" Bootstrap vundle if this is a new install.
if !isdirectory($HOME . '/.vim/bundle/Vundle.vim')
  if executable('git')
    if has('win32') || has ('win64')
      execute '!"git clone https://github.com/gmarik/vundle.git "'
      \ . $HOME . '/.vim/bundle/Vundle.vim""'
    else
      execute '!git clone https://github.com/gmarik/vundle.git "'
      \ . $HOME . '/.vim/bundle/Vundle.vim"'
    endif
    autocmd VimEnter * PluginInstall
  else
    let choice =  confirm("You should get Git to be able to
      \ Install and Update. Continue?", "&Yes\n&No", 2)
    if choice == 2
      quit
    endif
  endif
endif
" Now we can assume the vundle is installed.
""""""""""""" </ Vundle Setup > """"""""""""""

"""""""""""" < Vundle Plugins > """"""""""""""
set rtp+=~/.vim/bundle/Vundle.vim
set rtp+=~/.fzf
call vundle#begin()

" Plugin Management
Plugin 'VundleVim/Vundle.vim'

" Aesthetics
Plugin 'xolox/vim-misc'                   " Misc needed for other plugins?
Plugin 'vim-airline/vim-airline'          " Better status bar
Plugin 'vim-airline/vim-airline-themes'
Plugin 'flazz/vim-colorschemes'
Plugin 'valloric/MatchTagAlways'
Plugin 'nathanaelkane/vim-indent-guides'  " Colored tab indent levels
Plugin 'croaker/mustang-vim'

" Languages
Plugin 'scrooloose/syntastic'
"Plugin 'sheerun/vim-polyglot'

" Searching
Plugin 'ervandew/ag'
Plugin 'kien/ctrlp.vim'                 " Fuzzy file search from current dir.
" Plugin 'xolox/vim-easytags'

" Windows and Buffers
Plugin 'majutsushi/tagbar'              " Display ctags in a sidebar.
Plugin 'godlygeek/tabular'              " Needed for vim-markdown, should be loaded in this order
Plugin 'scrooloose/nerdtree'            " File navigation buffer
Plugin 'rbgrouleff/bclose.vim'
Plugin 'ap/vim-buftabline'
Plugin 'benmills/vimux'

" Input
Plugin 'terryma/vim-multiple-cursors'
Plugin 'ervandew/supertab'
Plugin 'scrooloose/nerdcommenter'        " Line comment toggling
Plugin 'Townk/vim-autoclose'
"let g:AutoClosePairs_add = "$"
Plugin '907th/vim-auto-save'
Plugin 'tpope/vim-repeat'

" Markdown
"Plugin 'plasticboy/vim-markdown'
Plugin 'vim-pandoc/vim-pandoc'
Plugin 'vim-pandoc/vim-pandoc-syntax'
Plugin 'KeitaNakamura/tex-conceal.vim'
let g:tex_conceal="abdgm"
Plugin 'tpope/vim-surround'
Plugin 'dkarter/bullets.vim'
"Plugin 'masukomi/vim-markdown-folding'
Plugin 'ferrine/md-img-paste.vim'
" there are some defaults for image directory and image name, you can change them
let g:mdip_imgdir = 'figures'
" let g:mdip_imgname = 'image'

" Latex
Plugin 'lervag/vimtex'
Plugin 'SirVer/ultisnips'
" Snippets are separated from the engine. Add this if you want them:
Plugin 'honza/vim-snippets'


call vundle#end()
"""""""""""" </ Vundle Plugins > """""""""""""""
" call pathogen#infect()

set nocompatible
set viminfo='1000,f1,:1000,/1000
set history=1000

"------  Visual Options  ------
syntax on
set number
set nowrap
set vb
set ruler
let g:buftabs_only_basename=1
let g:buftabs_marker_modified = "+"
set t_ut=

"set listchars=eol:$,tab:>-,trail:~,extends:>,precedes:<

" Linebreak on 500 characters
set lbr
set tw=500

" Treat long lines as break lines (useful when moving around in them)
nnoremap j gj
nnoremap k gk

"""------  Generic Behavior  ------
" Use spaces instead of tabs (necessary for haskell/ghc)
set tabstop=2     " Inserts 2 spaces when tab key is pressed.
set softtabstop=2 " Deletes 2 spaces (simulates deleting a tab)
set shiftwidth=2  " Inserts 2 spaces for auto-indentation.
set expandtab     " Insert spaces whenever tab key is pressed.
set smarttab      " ?
set shiftround    " Round indent to nearest 'shiftwidth' multiple

set hidden
filetype indent on
filetype plugin on
set autoindent    " Match indentation level when moving to new line.
set smartindent

"allow deletion of previously entered data in insert mode
set backspace=indent,eol,start

set viminfo^=%                    " Remember info about open buffers on close

set wildmenu                      " Turn on the WiLd menu
set wildmode=list:longest,full    " Tab-complete files up to longest unambiguous prefix

" For the love of god, don't grep min files!
set wildignore=.svn,CVS,.git,*.o,*.a,*.class,*.mo,*.la,*.so,*.obj,*.swp,*.jpg,*.png,*.xpm,*.gif,node_modules/*
set wildignore+=*.min,*.min.js,*.tmp,*.svg

set ignorecase                    " Ignore case when searching
set smartcase                     " When searching try to be smart about cases

set lazyredraw                    " Don't redraw while executing macros (good performance config)

set nobackup                      " Turn backup off (store everything in version control)
set nowb
set noswapfile

set wrap                          " Wrap lines longer than window width

" Not compiled into some versions of vim, i.e. ubuntu default repos.
if exists("&breakindent")
  set breakindent                   " Indent wraps to same level as original line
endif

" set breakindent                   " Indent wraps to same level as original line
" Incompatible with debian vim?


"""""""""""""""""""" <Misc> """"""""""""""
" Automatically use the system clipboard for copy-paste (instead of internal registers)
set clipboard+=unnamedplus

" GUI Settings
set t_Co=256
"colorscheme 3dglasses 
"colorscheme afterglow 
"colorscheme apprentice
colorscheme SweetCandy

set mouse=a                     " Allow mouse selection

set showmatch                   " Show matching parens
set smarttab                    " Indents based on sw, not ts
set hlsearch                    " Highlight search terms
set incsearch                   " Show search matches as typed

set backspace=indent,eol,start  " Allow backspace over anything
set ff=unix                     " Default to Unix LF line endings

set noswapfile                  " Use version control instead

" Make sure unicode works properly (primarily for concealing)
set encoding=utf-8
let &termencoding=&encoding
"""""""""""""   < Keymaps > """"""""""""""""""

let mapleader=","

" Haskell shortcuts
"map <Leader>m :w \| make<CR>

"map <Leader>m :w \| !xelatex --interaction=batchmode %; rm *.{aux,log,out,dvi,nav,toc,pre,tdo}<CR><CR>
"autocmd BufWritePost *.tex :silent execute "!xelatex --interaction=batchmode %; rm *.{aux,log,out}" | redraw!
"let blacklist = ['preamble.tex']
"autocmd BufWritePost *.tex if expand('%:t') != "preamble.tex" | :silent execute "!pdflatex %; rm *.{aux,log,out}" | redraw!

" Then type in word to ag from the curent directory
"map <Leader>/ :Ag!<SPACE>

" Ag the word under the cursor.
"nmap <Leader>// :<c-u>execute 'Ag! ' .  expand("<cWORD>")<CR>

" Allow saving of read-only files when opened without sudo.
cmap wf %!sudo tee > /dev/null %

" ,q Closes the current buffer
nnoremap <silent> <Leader>q :Bclose<CR>

" cscope the word under the cursor
"nnoremap <silent> <C-\> :cs find c <C-R>=expand("<cword>")<CR><CR>

" Clear search highlights when pressing ,b
"nnoremap <silent> <leader>b :nohlsearch<CR>

" Press enter to clear search highlights
nnoremap <CR> :noh<CR><CR>

" Toggle NerdTree visibility using ,n
noremap <silent> <Leader>n :NERDTreeToggle<CR>

" ,hljk = Move between windows
nnoremap <Leader>h <C-w>h
nnoremap <Leader>l <C-w>l
nnoremap <Leader>j <C-w>j
nnoremap <Leader>k <C-w>k

" Ctrl Left/h & Right/l cycle between buffers
"noremap <silent> <C-Left> :bprev<CR>
"noremap <silent> <C-h> :bprev<CR>
"noremap <silent> <C-Right> :bnext<CR>
"noremap <silent> <C-l> :bnext<CR>

" Some custom programming commands
"nnoremap <Leader>mm :wa \| :VimuxRunCommand 'make clean && make all && ./test'<CR>
"nnoremap <leader>cap :wa \| :VimuxRunCommand 'git add *; git commit -am "save"; git push origin master'<CR>
" Close buffer without affecting splits.
"nnoremap <leader>w :Bclose<CR>
nnoremap <leader>w :bp\|bd #<CR>

" Cmd+t = new tab
nnoremap <silent> <Leader>t :tabnew<CR>

" Cmd+w = close tab (this should happen by default)
"nnoremap <silent> <Leader>w :tabclose<CR>

" Cmd+Shift+N = new buffer
" map <silent> <Leader>n :enew<CR>

" Toggle between absolute and relative line numbers
function! NumberToggle()
  if (&relativenumber == 1)
    set norelativenumber
  else
    set relativenumber
  endif
endfunc

""""""""""""" < /Keymaps > """"""""""""""""""""""""""""""
set statusline+=%#warningmsg#
set statusline+=%{SyntasticStatuslineFlag()}
set statusline+=%*

set laststatus=2
set statusline=%<%f\                        " Filename
set statusline+=%w%h%m%r                    " Options
set statusline+=\ [%{&ff}/%Y]               " filetype
set statusline+=\ [%{getcwd()}]             " current dir
set statusline+=%=%-14.(%l,%c%V%)\ %p%%     " Right aligned file nav info

" Prevent cursor from moving to beginning of line when switching buffers
set nostartofline

" Keep the cursor in place while joining lines
nnoremap J mzJ`z


""""""""" < Search > """""""""""
set incsearch
set ignorecase
set smartcase
set hlsearch

" When searching for words with * and navigating with N/n, keep line centered vertically
nnoremap n nzz
nnoremap N Nzz
nnoremap * *zz
nnoremap # #zz
nnoremap g* g*zz
nnoremap g# g#zz
""""""""" </ Search > """""""""""


""""""""""""" < NerdTree > """"""""""""""""""
" Always open NerdTree along with files
" and switch focus to file
" au VimEnter * NERDTree | wincmd p

" Custom commands for NERDTree
autocmd StdinReadPre * let s:std_in=1
" autocmd VimEnter * if argc() == 0 && !exists("s:std_in") | NERDTree | endif

let NERDTreeIgnore=['CVS','\.dSYM$']

"setting root dir in NT also sets VIM's cd
let NERDTreeChDirMode=2

let g:NERDTreeDirArrows=0

" These prevent accidentally loading files while focused on NERDTree
autocmd FileType nerdtree noremap <buffer> <c-left> <nop>
autocmd FileType nerdtree noremap <buffer> <c-h> <nop>
autocmd FileType nerdtree noremap <buffer> <c-right> <nop>
autocmd FileType nerdtree noremap <buffer> <c-l> <nop>

" Open NERDTree if we're executing vim without specifying a file to open
autocmd vimenter * if !argc() | NERDTree | endif

" Close if only NERDTree open
autocmd bufenter * if (winnr("$") == 1 && exists("b:NERDTreeType") && b:NERDTreeType == "primary") | q | endif

" Hides "Press ? for help"
let NERDTreeMinimalUI=1
""""""""""""" </ NerdTree > """"""""""""""""""

"au FileType php set omnifunc=phpcomplete#CompletePHP
" ----- </ PHP > -------------------

" Column 80 marker
" highlight OverLength ctermbg=red ctermfg=white guibg=#660000
" match OverLength /\%81v.\+/

" Sane vimdiff colorscheme
highlight DiffAdd    cterm=bold ctermfg=10 ctermbg=17 gui=none guifg=bg guibg=Red
highlight DiffDelete cterm=bold ctermfg=10 ctermbg=17 gui=none guifg=bg guibg=Red
highlight DiffChange cterm=bold ctermfg=10 ctermbg=17 gui=none guifg=bg guibg=Red
highlight DiffText   cterm=bold ctermfg=10 ctermbg=88 gui=none guifg=bg guibg=Red

" Turn on HTML tag matching
runtime macros/matchit.vim

"""""""""" < CtrlP >
" CtrlP will load from the CWD, makes it easier with all these nested repos
let g:ctrlp_working_path_mode = ''

let g:ctrlp_map = '<c-p>'
let g:ctrlp_cmd = 'CtrlP'
let g:ctrlp_working_path_mode='ra'

let g:ctrlp_clear_cache_on_exit=0       " Save cache for a small speedup.

" Use ag for Ctrl-P for speed improvement.
if executable('ag')
    set grepprg=ag\ --nogroup\ --nocolor
    let g:ctrlp_user_command = 'ag %s -l --nocolor -g ""'
    let g:ctrlp_use_caching=0
endif
"""""""""" </ CtrlP >

" Close NerdTree if it is the only buffer left open.
function! NERDTreeQuit()
  redir => buffersoutput
  silent buffers
  redir END
"                     1BufNo  2Mods.     3File           4LineNo
  let pattern = '^\s*\(\d\+\)\(.....\) "\(.*\)"\s\+line \(\d\+\)$'
  let windowfound = 0

  for bline in split(buffersoutput, "\n")
    let m = matchlist(bline, pattern)

    if (len(m) > 0)
      if (m[2] =~ '..a..')
        let windowfound = 1
      endif
    endif
  endfor

  if (!windowfound)
    quitall
  endif
endfunction
autocmd WinEnter * call NERDTreeQuit()

" Remove trailing whitespace before writing (applies to all files)
"autocmd BufWritePre * :%s/\s\+$//e

" Recognize .md files as markdown
"autocmd BufNewFile,BufReadPost *.md set filetype=markdown

" Return to last edit position when opening files
augroup last_edit
  autocmd!
  autocmd BufReadPost *
       \ if line("'\"") > 0 && line("'\"") <= line("$") |
       \   exe "normal! g`\"" |
       \ endif
augroup END

" Source the vimrc file after saving it
augroup sourcing
  autocmd!
  autocmd bufwritepost .vimrc source $MYVIMRC
augroup END

" After narrowing choices, allows pressing enter to select last entry in popup menu.
inoremap <expr> <CR> pumvisible() ? "\<C-y>" : "\<C-g>u\<CR>"

" Display buffers in tabs when only one tab is open
let g:airline#extensions#tabline#enabled = 1

"let g:syntastic_always_populate_loc_list = 1
let g:syntastic_auto_loc_list = 0
"let g:syntastic_check_on_open = 0
let g:syntastic_check_on_wq = 0
"let g:syntastic_cpp_compiler_options=' -std=c++11 -stdlib=libc++'

" Enable syntax checking on write/close, but disable on haskell files
" (Intensive for large projects)
"let g:syntastic_mode_map = {
        "\ "mode": "active",
        "\ "active_filetypes": ["ruby", "php"],
        "\ "passive_filetypes": ["haskell", "tex"] }
"let g:syntastic_enable_signs=1

" Automatically :set-paste when pasting from clipboard, in insert mode
function! WrapForTmux(s)
  if !exists('$TMUX')
    return a:s
  endif

  let tmux_start = "\<Esc>Ptmux;"
  let tmux_end = "\<Esc>\\"

  return tmux_start . substitute(a:s, "\<Esc>", "\<Esc>\<Esc>", 'g') . tmux_end
endfunction

let &t_SI .= WrapForTmux("\<Esc>[?2004h")
let &t_EI .= WrapForTmux("\<Esc>[?2004l")

function! XTermPasteBegin()
  set pastetoggle=<Esc>[201~
  set paste
  return ""
endfunction

inoremap <special> <expr> <Esc>[200~ XTermPasteBegin()

"let g:tex_conceal = ""
let g:vim_markdown_math = 1
let g:vim_markdown_frontmatter = 1
let g:vim_markdown_toc_autofit = 1
let g:vim_markdown_follow_anchor = 1
let g:vim_markdown_frontmatter = 1
let g:vim_markdown_new_list_item_indent = 0

"autocmd BufRead,BufNewFile *.md,tex,latex setlocal spell
autocmd FileType markdown,tex,latex setlocal spell
" Fix the omnicomplete popup menu a bit
" Allows typing in a few characters to narrow down the list
set completeopt=longest,menuone
"set complete=kspell,.
set complete+=kspell
set complete+=k/home/zack/math_dict.txt
set spelllang=en
set spellfile=/home/zack/mathdict.utf-8.add
set conceallevel=2
" Use buffer words as default tab completion
"let g:SuperTabDefaultCompletionType = '<c-x><c-p>'
autocmd FileType *
  \ if &omnifunc != '' |
  \   call SuperTabChain(&omnifunc, "<c-p>") |
  \ endif

let g:tex_conceal="abdgm"
au FileType markdown autocmd VimEnter * hi clear Conceal         " Remove background color from concealed characters (grey on grey??)

hi NonText ctermbg=none
hi Normal guibg=NONE ctermbg=NONE

" Automatically re-read changed files
set autoread

" Automatically save after a few seconds
au CursorHold *.tex,*.md  update

" inoremap { {}<Esc>i
let g:polyglot_disabled = ['latex']

let g:UltiSnipsExpandTrigger="<c-l>"
"let g:UltiSnipsJumpForwardTrigger="<tab>"
"let g:UltiSnipsJumpBackwardTrigger="<s-tab>"
"let g:UltiSnipsExpandTrigger="<tab>"
"let g:UltiSnipsJumpForwardTrigger="<tab>"
"let g:UltiSnipsJumpBackwardTrigger="<s-tab>"

set foldlevel=20

" Autosave settings
"let g:auto_save        = 1
"let g:auto_save_silent = 1
"let g:auto_save_events = ["InsertLeave", "FocusLost"]

" Persistent Undo
let s:undoDir = "/tmp/.undodir_" . $USER
if !isdirectory(s:undoDir)
    call mkdir(s:undoDir, "", 0700)
endif
let &undodir=s:undoDir
set undofile

" Press Ctrl-B to change this line to a latex begin/end.
"map  <C-B>      YpkI\begin{<ESC>A}<ESC>jI\end{<ESC>A}<esc>k$o
"map! <C-B> <ESC>YpkI\begin{<ESC>A}<ESC>jI\end{<ESC>A}<esc>k$o

"nnoremap <Leader>b  YpkI\wrapenv{\Begin{<ESC>A}}<ESC>jI\wrapenv{\End{<ESC>A}}<esc>k$o<esc>
"nnoremap <C-b>  YpkI\wrapenv{\Begin{<ESC>A}}<ESC>jI\wrapenv{\End{<ESC>A}}<esc>k$o<esc>
"map! <C-B> <ESC>YpkI\begin{<ESC>A}<ESC>jI\end{<ESC>A}<esc>k$o

" Quickly insert an empty new line without entering insert mode
nnoremap <Leader>o o<Esc>
nnoremap <Leader>O O<Esc>
nnoremap <Leader>bi :execute "normal \<PLUG>Yssurround*"<CR>
nnoremap <Leader>bb :execute "normal \<PLUG>Yssurround*"<CR> :execute "normal \<PLUG>Yssurround*"<CR>


nnoremap <Leader>mm   I<CR>\begin{align*}<CR>.\end{align*}<CR><ESC>kO<ESC>
nnoremap <Leader>bc   I\begin{cases}<CR>\end{cases}<CR><ESC>kO<ESC>
nnoremap <Leader>bce   I\begin{center}<CR><CR>\end{center}<CR><ESC>
nnoremap <Leader>mat  i\left[\begin{array}{cc} 0 & 0 \\ 0 & 0 \end{array}\right]<ESC>
nnoremap <Leader>Mat  i\left[\begin{array}{cc}<CR>0 & 0 \\<CR>0 & 0 <CR>\end{array}\right]<ESC>
nnoremap <Leader>bct  i\begin{center}<ESC>
nnoremap <Leader>ect  i\end{center}<ESC>
nnoremap <Leader><Enter> i<CR><Esc>k$
"autocmd FileType markdown set foldexpr=NestedMarkdownFolds()

noremap <C-f> <Esc>: silent exec '.!xournal'
"nmap <Leader>// :<c-u>execute 'Ag! ' .  expand("<cWORD>")<CR>
autocmd FileType markdown nmap <silent> <leader>p :call mdip#MarkdownClipboardImage()<CR><CR><CR>

command Latex !latex_preview "%"
command Tikzcd :r!echo '\\begin{center}\n\\begin{tikzcd}\n\n\\end{tikzcd}\n\\end{center}'
nmap <Leader>ll :let @+=expand("%:p")<CR><CR>

hi clear Conceal

" Save folds between sessions
"augroup AutoSaveFolds
  "autocmd!
  "autocmd BufWinLeave * mkview
  "autocmd BufWinEnter * silent loadview
"augroup END

" Prevent cursor jumping?
let g:syntastic_auto_jump = 0

" Ctrl-R after visual select to replace
vnoremap <C-r> "hy:%s/<C-r>h//gc<left><left><left>

let g:polyglot_disabled = ['javascript', 'html']
"syntax region Statement matchgroup=Delimiter start="\\begin{.*}" end="\\end{.*}" contains=Statement
au! BufNewFile,BufFilePre,BufRead *.md set filetype=markdown.pandoc 

" Jump to headers
function! s:JumpToHeader(forward, visual)
  let cnt = v:count1
  let save = @/
  let pattern = '\v^#{1,1} .*$|^.+\n%(\-+|\=+)$'
  if a:visual
    normal! gv
  endif
  if a:forward
    let motion = '/' . pattern
  else
    let motion = '?' . pattern
  endif
  while cnt > 0
	  silent! execute motion
	  let cnt = cnt - 1
  endwhile
  call histdel('/', -1)
  let @/ = save
endfunction

noremap <silent> <buffer> <script> ]] :<C-u>call <SID>JumpToHeader(1, 0)<CR>
noremap <silent> <buffer> <script> [[ :<C-u>call <SID>JumpToHeader(0, 0)<CR>
vnoremap <silent> <buffer> <script> ]] :<C-u>call <SID>JumpToHeader(1, 1)<CR>
vnoremap <silent> <buffer> <script> [[ :<C-u>call <SID>JumpToHeader(0, 1)<CR>
noremap <silent> <buffer> <script> ][ <nop>
noremap <silent> <buffer> <script> [] <nop>


" No spellchecking fullstops without capitalization
set spellcapcheck=

" Fix Ctrl-Left/Right
map  <ESC>[1;5D] <C-Left>
map  <ESC>[1;5C] <C-Right>
map! <ESC>[1;5D] <C-Left>
map! <ESC>[1;5C] <C-Right>


" Fix capital W writing
command! W  write
