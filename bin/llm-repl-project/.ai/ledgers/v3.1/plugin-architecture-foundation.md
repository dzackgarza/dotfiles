# Plugin Architecture Foundation

**Branch:** feat/plugin-architecture-foundation
**Summary:** Convert V3-minimal's hardcoded classes into a proper plugin-based architecture where all timeline operations flow through validated, self-contained plugin instances.
**Status:** Planning
**Created:** 2025-07-10
**Updated:** 2025-07-10

## Context

### Problem Statement
V3-minimal violates the fundamental Sacred Timeline principle that "the UI reflects the architecture" and "each block corresponds to a self-contained, independently testable plugin." Instead of plugins, it uses hardcoded classes that directly manipulate the timeline, breaking the plugin-only architecture and making the system non-extensible.

### Success Criteria
- [ ] All timeline blocks are generated by validated plugins
- [ ] Plugin system supports independent development and testing
- [ ] Core plugins handle Sacred Turn Structure (User → Cognition → Assistant)
- [ ] Plugin discovery and loading system implemented
- [ ] Plugin dependency injection and lifecycle management

### Acceptance Criteria
- [ ] Timeline can only be modified through plugin instances
- [ ] New plugins can be added without modifying core system
- [ ] Each plugin is testable in complete isolation
- [ ] Plugin contracts enforce transparency requirements
- [ ] Plugin failure handling prevents system crashes

## User-Visible Behaviors

When this ledger is complete, the user will see:

- **All timeline operations flow through validated plugin instances.**
- **New plugins can be added without modifying the core system.**
- **Each plugin is testable in complete isolation.**
- **Plugin contracts enforce transparency requirements.**
- **Plugin failure handling prevents system crashes.**

## Technical Approach

### Architecture Changes
1. **Plugin Base Classes**: `BlockPlugin` abstract base with lifecycle methods
2. **Plugin Manager**: Discovery, loading, dependency injection, lifecycle
3. **Plugin Registry**: Central registry of available plugins
4. **Core Plugins**: Convert existing functionality to plugin architecture
5. **Plugin Lifecycle**: State machine for plugin execution phases

### Implementation Plan
1. **Phase 1: Planning** - Review and plan implementation
2. **Phase 2: Implementation** - Core development work
3. **Phase 3: Testing** - Testing and validation
4. **Phase 4: UX Polish** - Final polish and user experience improvements
5. **Phase 5: Integration** - Integrate ledger into the main system

### Dependencies
- Plugin Validator System (validates all plugins before activation)
- LLM Integration Foundation (for real LLM-based plugins)
- Sacred Timeline Persistence (plugins inscribe to persistent timeline)

### Risks & Mitigations
- **Risk 1**: Performance overhead from plugin abstraction
  - *Mitigation*: Efficient plugin loading, caching, optimized contracts
- **Risk 2**: Complex dependency management between plugins
  - *Mitigation*: Clear dependency specification, topological sorting
- **Risk 3**: Plugin compatibility issues during development
  - *Mitigation*: Versioned plugin contracts, compatibility testing

## Progress Log

### 2025-07-10 - Initial Planning
- Identified hardcoded class architecture violating plugin principles
- Analyzed V2 plugin system for reference implementation
- Designed plugin abstraction and lifecycle management
- Created migration strategy for existing V3-minimal code

## Technical Decisions

### Decision 1: Plugin Base Class Design
**Context**: Need flexible plugin interface supporting different types of operations  
**Options**: Single interface, multiple inheritance, composition-based, protocol-based  
**Decision**: Abstract base class with protocol validation  
**Reasoning**: Type safety with runtime flexibility, clear contract definition  
**Consequences**: Strong typing and clear plugin development guidelines

### Decision 2: Plugin Lifecycle Management
**Context**: Plugins need controlled initialization, activation, processing phases  
**Options**: Simple callbacks, state machine, event-driven, functional  
**Decision**: Explicit state machine with lifecycle methods  
**Reasoning**: Clear state transitions, error handling, debugging support  
**Consequences**: More complex but predictable plugin behavior

### Decision 3: Dependency Injection Strategy
**Context**: Plugins need access to timeline, LLM providers, other plugins  
**Options**: Constructor injection, property injection, service locator  
**Decision**: Constructor injection with interface definitions  
**Reasoning**: Explicit dependencies, testability, compile-time validation  
**Consequences**: Clear dependencies but more complex plugin initialization

## Plugin Architecture Design

### BlockPlugin Base Class
```python
class PluginState(Enum):
    INACTIVE = "inactive"
    INITIALIZING = "initializing"
    ACTIVE = "active"
    PROCESSING = "processing"
    COMPLETED = "completed"
    ERROR = "error"

@dataclass
class PluginMetadata:
    name: str
    version: str
    description: str
    author: str
    capabilities: List[str]
    dependencies: List[str] = field(default_factory=list)

class BlockPlugin(ABC):
    def __init__(self, plugin_id: str = None):
        self.plugin_id = plugin_id or str(uuid.uuid4())
        self.state = PluginState.INACTIVE
        self._timer = Timer()
        self._token_counter = TokenCounter()
    
    @property
    @abstractmethod
    def metadata(self) -> PluginMetadata:
        pass
    
    @abstractmethod
    async def initialize(self, config: Dict[str, Any]) -> bool:
        pass
    
    @abstractmethod
    async def activate(self) -> None:
        pass
    
    @abstractmethod
    async def process(self, input_data: Any, context: Dict[str, Any]) -> Any:
        pass
    
    @abstractmethod
    async def render(self, context: RenderContext) -> Dict[str, Any]:
        pass
    
    @abstractmethod
    async def deactivate(self) -> None:
        pass
```

### Plugin Manager
```python
class PluginManager:
    def __init__(self, validator: PluginValidator):
        self._validator = validator
        self._plugins: Dict[str, BlockPlugin] = {}
        self._plugin_configs: Dict[str, Dict] = {}
    
    def register_plugin(self, plugin_class: Type[BlockPlugin]) -> bool:
        plugin = plugin_class()
        if self._validator.validate_plugin(plugin):
            self._plugins[plugin.metadata.name] = plugin
            return True
        return False
    
    async def load_plugin(self, name: str, config: Dict = None) -> BlockPlugin:
        plugin = self._plugins[name]
        await plugin.initialize(config or {})
        await plugin.activate()
        return plugin
    
    def discover_plugins(self, directory: Path) -> List[Type[BlockPlugin]]:
        # Dynamic plugin discovery from filesystem
        pass
```

## Core Plugin Implementations

### UserInputPlugin
```python
class UserInputPlugin(BlockPlugin):
    @property
    def metadata(self) -> PluginMetadata:
        return PluginMetadata(
            name="user_input",
            version="1.0.0",
            description="Captures and validates user input",
            author="LLM REPL Core",
            capabilities=["input_capture", "input_validation"]
        )
    
    async def process(self, input_data: str, context: Dict[str, Any]) -> Dict[str, Any]:
        self.state = PluginState.PROCESSING
        self._timer.start()
        
        # Validate and sanitize input
        sanitized_input = self._sanitize_input(input_data)
        
        self.state = PluginState.COMPLETED
        self._timer.stop()
        
        return {
            "content": sanitized_input,
            "metadata": {
                "length": len(sanitized_input),
                "processing_time": self._timer.duration
            }
        }
```

### CognitionPlugin
```python
class CognitionPlugin(BlockPlugin):
    def __init__(self, llm_manager: LLMManager):
        super().__init__()
        self.llm_manager = llm_manager
        self.cognitive_modules: List[CognitiveModule] = []
    
    @property
    def metadata(self) -> PluginMetadata:
        return PluginMetadata(
            name="cognition",
            version="1.0.0", 
            description="Orchestrates cognitive processing pipeline",
            author="LLM REPL Core",
            capabilities=["query_processing", "llm_orchestration"],
            dependencies=["llm_manager"]
        )
    
    async def process(self, input_data: Dict, context: Dict[str, Any]) -> Dict[str, Any]:
        self.state = PluginState.PROCESSING
        self._timer.start()
        
        results = []
        for module in self.cognitive_modules:
            result = await module.process(input_data, self.llm_manager)
            results.append(result)
            self._token_counter.add_tokens(result.tokens)
        
        self.state = PluginState.COMPLETED
        self._timer.stop()
        
        return {
            "steps": results,
            "final_output": results[-1].content if results else "",
            "total_tokens": self._token_counter.total,
            "processing_time": self._timer.duration
        }
```

### AssistantResponsePlugin
```python
class AssistantResponsePlugin(BlockPlugin):
    @property
    def metadata(self) -> PluginMetadata:
        return PluginMetadata(
            name="assistant_response",
            version="1.0.0",
            description="Formats and presents final responses",
            author="LLM REPL Core",
            capabilities=["response_formatting", "output_rendering"]
        )
    
    async def process(self, input_data: Dict, context: Dict[str, Any]) -> Dict[str, Any]:
        # Format cognition output into user-friendly response
        response = self._format_response(input_data)
        return {"content": response}
```

## Plugin Discovery System

### Plugin Directory Structure
```
plugins/
├── core/
│   ├── __init__.py
│   ├── user_input.py
│   ├── cognition.py
│   └── assistant_response.py
├── extensions/
│   ├── web_search.py
│   ├── code_analysis.py
│   └── file_operations.py
└── user/
    └── custom_plugin.py
```

### Plugin Registration
```python
# Automatic discovery and registration
plugin_manager = PluginManager(validator)
core_plugins = plugin_manager.discover_plugins(Path("plugins/core"))
for plugin_class in core_plugins:
    plugin_manager.register_plugin(plugin_class)
```

## Testing Strategy

### Unit Tests
- [ ] Plugin base class functionality
- [ ] Plugin lifecycle state transitions
- [ ] Plugin manager registration and loading
- [ ] Individual plugin implementations

### Integration Tests
- [ ] Full Sacred Turn Structure through plugins
- [ ] Plugin dependency resolution
- [ ] Plugin failure handling and recovery
- [ ] Plugin hot-loading and reloading

### Manual Testing
- [ ] Plugin development workflow
- [ ] Custom plugin creation and loading
- [ ] Plugin error scenarios
- [ ] Plugin performance profiling

## Documentation Updates

- [ ] Plugin development guide and tutorial
- [ ] Plugin API reference documentation
- [ ] Core plugin documentation
- [ ] Plugin architecture design guide

## Migration Strategy

### Phase 1: Parallel Implementation
- Implement plugin system alongside existing hardcoded classes
- Create plugin versions of existing functionality
- Test plugin system in isolation

### Phase 2: Gradual Replacement
- Replace hardcoded classes with plugin equivalents one by one
- Maintain backward compatibility during transition
- Add plugin validation for new implementations

### Phase 3: Full Migration
- Remove all hardcoded timeline manipulation
- Enforce plugin-only architecture
- Add comprehensive plugin ecosystem tools

## Completion

### Final Status
- [ ] All timeline operations flow through validated plugins
- [ ] Core plugins (User, Cognition, Assistant) implemented
- [ ] Plugin manager with discovery and lifecycle management
- [ ] Plugin development tools and documentation
- [ ] Migration from hardcoded classes complete

### Follow-up Items
- [ ] Advanced plugin marketplace and distribution
- [ ] Plugin sandboxing and security framework
- [ ] Plugin performance optimization and caching
- [ ] Plugin collaboration and composition tools

---

*This ledger tracks the transformation of V3-minimal from hardcoded classes to a proper plugin-based architecture aligned with Sacred Timeline principles.*