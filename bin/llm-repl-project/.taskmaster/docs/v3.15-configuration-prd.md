# Sacred GUI V3.15: Configuration-Driven Architecture

This PRD defines the 7 V3.15 ledgers focused on configuration consolidation and architectural cleanup, transforming the system into a YAML-driven, maintainable codebase.

## Overview

V3.15 addresses architectural debt by consolidating configuration, removing unused code, and isolating testing infrastructure. The goal is enabling fine-tuning without code modification through comprehensive YAML configuration.

## Core Requirements

### Phase 1: Foundation (Parallel Execution)

#### YAML Configuration Foundation
Establish comprehensive YAML configuration system:
- Enhanced ConfigLoader with validation and schema definition
- Hot-reload capability for development workflows
- Default configuration generation and management
- Comprehensive YAML schema design for all configurable values
- Configuration validation with clear error messages

#### Unused Code Removal
Clean up codebase complexity:
- Remove unused InputProcessor completely with all references
- Consolidate 7 demo files to 3 canonical examples
- Clean up dead imports and unused dependencies
- Achieve 15-20% codebase size reduction
- Eliminate conflicting code paths and redundant implementations

#### Unified Timeline Ownership
Resolve fundamental LiveBlock/Timeline conflicts:
- Establish single source of truth for all block management
- Clear ownership model with no state ambiguity
- Atomic state transitions preserving block relationships
- Proper state machine for complete block lifecycle
- Eliminate race conditions and ownership conflicts

### Phase 2: System Consolidation (Sequential Execution)

#### Animation System Consolidation
Eliminate deprecated systems and conflicts:
- Remove AnimationRates compatibility wrapper completely
- Migrate all timing logic to unified AnimationClock system
- YAML-configurable animation speeds for all components
- Environment-based FPS settings (development vs production)
- Consistent animation timing across all widgets

#### Mock System Isolation
Separate testing infrastructure from production:
- Clean production LiveBlock class without mock methods
- Dedicated mock API in `src/mocks/` submodule
- YAML-configurable mock scenarios and behaviors
- Clear separation between testing and production code paths
- Isolated mock dependencies and imports

#### Scroll Stealing Fix
Resolve timeline interaction issues:
- Separate progress callbacks from content update callbacks
- Smart auto-scroll that respects user navigation intent
- Smooth animations without scroll position interference
- Eliminate timing-based hacks and workarounds
- Preserve user's timeline review capability during live updates

### Phase 3: UI Configuration (Dependent on Foundation)

#### Widget CSS to YAML Migration
Enable visual configuration without code changes:
- CSS template system with YAML value injection
- All widget dimensions and spacing configurable via YAML
- Hot-reload of visual changes for immediate feedback
- Consistent spacing and sizing system across widgets
- Theme customization through configuration files

## Implementation Strategy

### Execution Dependencies
- Foundation Phase: All tasks can run in parallel
- Consolidation Phase: Sequential execution after foundation
- UI Configuration: Depends on YAML foundation completion

### Configuration Coverage Goals
- 90%+ of tunable values moved to YAML configuration
- All hardcoded dimensions extracted to configuration
- Animation timing completely configurable
- Mock scenarios and behaviors configurable
- Visual themes and styling configurable

### Code Quality Improvements
- 15-20% codebase size reduction through cleanup
- Elimination of duplicate and conflicting systems
- Clear separation of production and testing concerns
- Reduced API surface area through focused interfaces
- Comprehensive configuration documentation

## Success Criteria

### Developer Experience
- Configuration changes require no code modification
- Visual and timing changes visible immediately via hot-reload
- Clear separation between production and testing workflows
- All configuration options thoroughly documented
- Intuitive configuration schema and validation

### Performance Goals
- Startup time maintained or improved despite configuration loading
- Consistent 60fps animation performance in production mode
- Faster test execution with optimized timing configurations
- Reduced memory usage from eliminated duplicate systems
- Efficient configuration loading and validation

### Architectural Benefits
- Single animation system (AnimationClock only)
- Separated production and testing concerns completely
- Eliminated conflicting code paths and ownership ambiguity
- Consistent configuration patterns across all components
- Hot-reload development workflow for rapid iteration

This V3.15 series transforms the Sacred GUI into a configuration-driven system while eliminating architectural debt and improving maintainability, setting the foundation for advanced V3.2+ features.